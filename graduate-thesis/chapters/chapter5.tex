\chapter{基于图过滤的程序依赖图表征学习}
\label{chap:PDG}
本章主要对本文提出的基于图过滤的程序依赖图表征学习方法进行详细介绍，首先介绍其基本思想，其次阐述其具体方法设计与实现，最后进行实验验证。

\section{研究动机}
\label{sec:PDGMotivation}

程序依赖图PDG是代码的一种图形表示，所含结构信息最多，能够表示程序的控制依赖，数据依赖等关系，是一种带有标记的有向多重图。程序依赖图PDG结点代表语句，边代表依赖关系，依赖关系包括数据依赖和控制依赖。基于图的代码表征方法首先使用代码分析工具构建包含代码语法结构、调用关系、数据流等信息的程序依赖图，然后通过子图匹配的方法，将PDG图中的控制流和数据流编码为一个紧凑的语义特征矩阵，其中每个元素都是一个高维的稀疏二值特征向量。通过将代码表示为图的形式使得模型能够更好地理解代码中不同部分之间的依赖关系，更适合研究代码内的丰富语义信息。

基于图的代码表征方法存在两种主要限制：

（1）规模开销较高：基于图的表征学习方法通常需要构建代码的结构图或控制流图作为分析的基础，对于具有复杂控制流或数据流的代码片段，构建准确的图表示是一个不小的挑战。特别地，当代码片段中具有循环、递归或异常处理机制时，图的构建过程更加困难。这些复杂结构不仅增加图构建的复杂性，还有可能导致图表示的精度下降；即使在成功生成图之后，图表征学习方法的计算成本也很高。例如，对图进行子图同构等操作时，往往需要借助复杂的图算法来实现，并将生成的程序依赖图两两匹配，对于包含$n$个代码片段的数据集，需要进行$n^2$次匹配检测。而其中包含大量无用的匹配，会浪费大量的时间和计算资源。这些算法不仅计算成本大，而且随着代码库规模的扩大，处理时间也会显著增加，导致开销高。

（2）对代码修改的敏感性：在实际开发过程中，代码通常会经过各种微小的更改，例如变量名更改、代码格式化、添加或删除注释等，这些修改可能会导致图的表示发生显著变化。具体来说，当代码中的变量名被更改时，图的节点和边可能会受到影响，因为变量名通常作为图中的一个重要特征被考虑在内。同样，代码格式的调整，如缩进、换行或空格的变化，虽然不影响代码的逻辑功能，但也可能导致图的拓扑结构发生变化。此外，添加或删除注释虽然对代码的执行没有影响，但在构建代码图时，这些注释也可能被当作图的一部分，从而影响到图的表示。因此，基于图的克隆检测方法可能无法准确地检测出这些轻微修改过的克隆代码。更进一步，随着代码库的不断增长和变化，基于图的克隆检测方法可能需要不断地更新和调整以适应新的代码结构。这意味着方法的实现和维护成本可能会相对较高，因为开发者需要定期更新和调整方法以适应代码的变化。这种持续的更新和调整不仅增加了工作负担，还可能影响到方法的长期有效性。

因此，针对上述问题，本文提出了一种基于图过滤的程序依赖图表征学习方法，该方法通过预处理图过滤，减少候选PDG对集合的规模。

\section{PDG表征方法方法设计}
\label{sec:PDG}
本节将介绍基于图过滤的程序依赖图表征学习方法设计与实现，首先介绍该方法的整体框架，并从图过滤、程旭依赖图表征学习两方面介绍具体设计。 

\subsection{框架概述}
\label{subsec:PDGOverview}
本文提出的基于图过滤的程序依赖图表征学习方法整体框架如图\ref{fig:pdgframework}所示。该框架的输入是代码片段对应的程序依赖图，输出是对应的语义特征向量，主要包括图过滤、图表征两个阶段。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{figures/pdgframework.png}
  \caption{基于图过滤的程旭依赖图表征学习框架}\label{fig:pdgframework}
\end{figure}

首先，图过滤阶段以代码片段对应的程序依赖图作为训练数据，设计一个

其次，

在上述框架中，


\subsection{图过滤设计}
\label{subsec:PDGPreModel}

本文使用代码分析工具Joern生成程序依赖图。其中，Joern通过静态分析源代码，生成关键的图结构信息，反映代码中的依赖关系和函数调用层次，同时Joern提供查询和可视化功能，用户可以通过命令将分析结果导出为多种格式，从而更好地理解代码的逻辑和流程。使用Joern工具，生成代码片段\ref{fig:code1}对应的程序依赖图，并导出DOT文件如\ref{fig:pdgshili1}所示，使用开源图形可视化工具Graphviz对DOT文件进行转化，可以得到如\ref{fig:pdgshili2}的图形。

\begin{figure}[H]
  \centering
  \subfigure[代码片段1对应的PDG DOT格式]{   %第一张子图
      \centering    %子图居中
      \includegraphics[width=0.4\textwidth]{figures/pdgshili}  
      \label{fig:pdgshili1} %引用标签
  }
  \subfigure[代码片段1对应的PDG可视化]{ %第二张子图
      \centering    %子图居中
      \includegraphics[width=0.5\textwidth]{figures/pdgshili2}
      \label{fig:pdgshili2} %引用标签
  }
  \caption{程序依赖图DOT文件示例}
  \label{fig:pdgshili}
\end{figure}
% \lstset{language=C}
% \begin{lstlisting}
%   digraph "main" {  
%     "9" [label = <(METHOD,main)<SUB>4</SUB>> ]
%     "46" [label = <(METHOD_RETURN,int)<SUB>4</SUB>> ]
%     "12" [label = <(&lt;operator&gt;.assignment,i = 0)<SUB>6</SUB>> ]
%     "16" [label = <(&lt;operator&gt;.assignment,data[5]={1,2,3,4,5})<SUB>7</SUB>> ]
%     "25" [label = <(&lt;operator&gt;.assignment,result = 0)<SUB>8</SUB>> ]
%     "41" [label = <(printf,printf(&quot;%d&quot;,result))<SUB>14</SUB>> ]
%     "44" [label = <(RETURN,return 0;,return 0;)<SUB>15</SUB>> ]
%     "30" [label = <(&lt;operator&gt;.lessThan,i&lt;5)<SUB>10</SUB>> ]
%     "33" [label = <(&lt;operator&gt;.postIncrement,i++)<SUB>10</SUB>> ]
%     "45" [label = <(LITERAL,0,return 0;)<SUB>15</SUB>> ]
%     "18" [label = <(&lt;operator&gt;.arrayInitializer,{1,2,3,4,5})<SUB>7</SUB>> ]
%     "36" [label = <(&lt;operator&gt;.assignmentPlus,result += data[i])<SUB>12</SUB>> ]
%     "38" [label = <(&lt;operator&gt;.indirectIndexAccess,data[i])<SUB>12</SUB>> ]
%       "44" -> "46"  [ label = "DDG: &lt;RET&gt;"] 
%       "12" -> "46"  [ label = "DDG: i = 0"] 
%       "16" -> "46"  [ label = "DDG: data"] 
%       "16" -> "46"  [ label = "DDG: {1,2,3,4,5}"] 
%       "16" -> "46"  [ label = "DDG: data[5]={1,2,3,4,5}"] 
%       "25" -> "46"  [ label = "DDG: result = 0"] 
%       "30" -> "46"  [ label = "DDG: i"] 
%       "30" -> "46"  [ label = "DDG: i&lt;5"] 
%       ...
%       "30" -> "30"  [ label = "CDG: "] 
%       "30" -> "38"  [ label = "CDG: "] 
%       "30" -> "33"  [ label = "CDG: "] 
%       "30" -> "36"  [ label = "CDG: "] 
%     }
% \end{lstlisting}

%\notag \right.\\\left.

分析上图\ref{fig:pdgshili1}，程序依赖图DOT文件的描述包含两个部分：使用\textquotedbl number \textquotedbl [label =  <\(function,name\)> ]来描述PDG点的特征，包括节点编号、节点的标签，其中标签内还包括源代码语句中的变量名称、变量属性等信息。使用\textquotedbl number \textquotedbl $\to$ \textquotedbl number \textquotedbl [label = \textquotedbl CDG/DDG:data \textquotedbl ]来描述PDG边的特征，包括边的起始点编号、边的终点标号、边代表的依赖关系(控制依赖用CDG表示、数据依赖用DDG表示)。使用开源图形可视化工具得到的图\ref{fig:pdgshili2}中包含13个顶点，用实线箭头表示数据依赖边，虚线箭头表示控制依赖边。

如果代码片段功能复杂，那么对应的程序依赖图规模也会很大，同时包含很多冗余边。例如上图\ref{fig:pdgshili2}中红框中的边，它们起始节点、终止节点均相同。右上角的红框对应\ref{fig:pdgshili1}中的data数组，数组内包含5个元素，对应含有5条边。实际上，这些边只有数值不同，属性相同，因此需要进行适当的优化来使得程序程序依赖图的结构精简，又不会丢失语义信息。

针对上述问题，本文设计了一种基于候选图对集合的图过滤算法，算法的伪代码如\ref{alg3}所示。该算法有多个输入：候选程序依赖图集合$G$、PDG有效行数阈值$L$、程序依赖图对规模比率$T$，输出为：经过过滤后的PDG对集合$R$，初该算法分为四个步骤：PDG图结构化简、规模过滤、非同构判断、数值特征过滤，每个步骤的作用如下：

\begin{algorithm}[ht]  
	\renewcommand{\algorithmicrequire}{\textbf{Input:}}
	\renewcommand{\algorithmicensure}{\textbf{Output:}}
	\caption{Graph filter algorithm $\left(filter\_PDG\right)$}  
	\label{alg3}
	\begin{algorithmic}[1]
    \Require PDG pairs:$G$
    \Require The threshold:$L$
    \Require The threshold of PDG pair's scale ratio:$T$
    \Require The threshold of CV's string numberical similarity:$G_s$
		\Ensure Candidate PDG pairs:$R$
    \State initialization
		\For{each PDG paris $G_1,G_2$  $in$ $G$}
      \State deleteSelfLoops($G_1$)
      \State deleteSelfLoops($G_2$) \Comment{step1:PDG图结构化简}
      \If {sizeof($G_1$) < L or sizeof($G_2$) < L}
        \State PDG pair($G_1,G_2$) is filtered \Comment{step2:规模过滤}
      \Else
        \If {min($G_1,G_2$) / max($G_1,G_2$) < T}
          \If{there is subgraph between ($G_1,G_2$ )} \Comment{step3:非同构判断}
            \State R $\leftarrow$ R $\cup \left(G_1,G_2\right)$ 
          \Else
            \State PDG pair($G_1,G_2$ ) is filtered
          \EndIf
        \Else
          \If {number similarity of $G_1,G_2$ > $G_s$} \Comment{step4:数值特征过滤}
            \State R $\leftarrow$ R $\cup \left(G_1,G_2\right)$
          \Else
            \State PDG pair($G_1,G_2$ ) is filtered
          \EndIf
        \EndIf
      \EndIf 
    \EndFor \\
    \Return $R$
	\end{algorithmic}
\end{algorithm}

（1）PDG图结构化简：

（2）规模过滤：

（3）非同构判断：

（4）数字特征过滤：：


通过收集PDG的简单特征来过滤掉明显不可能为克隆的PDG对。具体的，根据PDG的节点个数、控制边数、执行边数、数据边数、声明节点数、函数调用数、传入参数、传出参数等代表特征进行过滤，在大幅减少候选PDG对规模的同时，保证真正的克隆对不会被过滤掉而导致整体克隆检出率的降低。


\subsection{程序依赖图表征学习设计}
\label{subsec:PDGModel}

（1）结构设计

为了提高程序依赖图维度代码表征能力，本文选取图卷积网络对上述得到程序依赖图进行建模。具体的模型设计如图\ref{fig:pdgmodel}所示。该模型主要包括输入层、多层卷积层、自注意力层、输出层。
\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/pdgmodel.png}
  \caption{程序依赖图表征模型设计}\label{fig:pdgmodel}
\end{figure}

（2）模型选型


对于提取到的程序依赖图，本课题拟通过图卷积神经网络将其转换成向量。


图卷积神经网络是一种特殊的前馈神经网络结构，为减少网络中参数个数，用卷积层来代替传统的全连接层，提高神经网络的训练效率，卷积神经网络可以提取信息最多的数据特征，生成一个固定大小的向量表示结构，从而挖掘深层次的语法和语义信息，在代码克隆检测任务中有较好的性能表现。

图卷积神经网络（GCN）的基本原理是通过卷积操作来提取图中节点的特征信息。在GCN中，节点的特征表示会考虑其邻居节点的特征，并通过学习得到的参数来更新。通过多层GCN的堆叠，可以逐步传播全局信息，实现对整个图的信息聚合和表示学习。GCN特别适合于那些节点表示和节点间关系都很重要的问题，如社交网络分析、分子结构识别、推荐系统等。


图中的每个结点无时无刻不因为邻居和更远的点的影响而在改变着自己的状态直到最终的平衡，关系越亲近的邻居影响越大。

GCN的主要思想：对于每个结点，我们都要考虑其所有邻居以及其自身所包含的特征信息。假设我们使用average()函数，那对每一个结点进行上述操作后，就可以得到能够输入到神经网络的平均值表示。




\section{PDG表征方法具体实现}
\label{sec:PDGachieve}
在介绍具体实现之前，本节首先给出PDG表征方法的输入：经过\ref{subsec:Preprocess}小节的代码预处理阶段，得到示例代码片段\ref{fig:code}对应的程序依赖图，如图\ref{fig:pdgcode}所示。图中的实线表示节点之间的控制依赖，虚线表示节点之间的数据依赖。仔细分析三张图，其中图\ref{fig:pdg1}和图\ref{fig:pdg2}红框中节点11、12虽然位置有所改变，但是其边依赖均相同，因此可以视为完全相同的同构图；而图\ref{fig:pdg3}因为增加了一个if语句，图中也增加了一个节点，同时添加的红色的线表示新增的数据依赖、控制依赖。

\begin{figure}[htbp]
  \centering  %居中
  \subfigure[C语言代码片段1对应的PDG]{   %第一张子图
      \centering    %子图居中
      \includegraphics[width=0.3\textwidth]{figures/pdg1}  
      \label{fig:pdg1} %引用标签
  }
  \subfigure[C语言代码片段2对应的PDG]{ %第二张子图
      \centering    %子图居中
      \includegraphics[width=0.3\textwidth]{figures/pdg2}
      \label{fig:pdg2} %引用标签
  }\subfigure[C语言代码片段3对应的PDG]{ %第二张子图
  \centering    %子图居中
  \includegraphics[width=0.3\textwidth]{figures/pdg3}
  \label{fig:pdg3} %引用标签
}
  \caption{示例源代码对应的程序依赖图}    %大图名称
  \label{fig:pdgcode}    %图片引用标记
\end{figure}

接下来，本章提出的基于图过滤的程序依赖图表征学习方法的实现如图\ref{fig:pdg}所示。该方法的输入是一对代码片段$C_{a},C_{b}$对应的程序依赖图，表示为$PDG_{a},PDG_{b}$，输出是$C_{a},C_{b}$对应的语义特征向量 $V_{a}^{PDG},V_{b}^{PDG}$，整体采用Siamese架构，两个子网络共享权值,从下到上，主要包括图过滤判断、图表征三个阶段。

\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/pdg.png}
  \caption{基于图过滤的程序依赖图表征学习方法实现}\label{fig:pdg}
\end{figure}

在图过滤阶段，

\section{实验验证}
\label{sec:PDGExperiment}
为了验证基于图过滤的程序依赖图表征学习方法的有效性，本文
\subsection{实验设计}
\label{sec:PDGDesign}
和3.3.1 相同
\subsection{实验结果}
\label{subsec:PDGResult}
消融对比实验：体现图过滤机制的有效性

基于PDG的GCN

基于PDG的+图过滤的GCN


\begin{table}
  \centering
  \caption{图过滤机制实验结果} %{tab:category}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}cccc}
  \toprule
    对比			&P		&R		&F1 \\
  \midrule
    基于PDG的GCN			&0.xx	&0.xx		&0.xx \\
    基于PDG的+图过滤的GCN			&0.xx		&0.xx		&0.xx \\
  \bottomrule
  \end{tabular*}
\end{table}

\section{本章小结}
\label{sec:Summary5}
本章主要对RLCCD中基于图过滤的程序依赖图表征学习方法的设计与实现进行详细阐述。首先介绍了程序依赖图维度的研究动机，其次介绍了程序依赖图表征学习的方法设计，具体论述了其整体框架、图过滤、图表征学习，接着开展实验验证，结果表明了此方法的有效性和模型的准确性。



