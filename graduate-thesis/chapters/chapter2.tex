\chapter{多维源代码表征学习方法总体设计}
\label{chap:design}

本章首先面向代码克隆任务给出需要解决问题的定义，然后提出当前代码表征学习面临的一些关键技术挑战，并基于此提出本文的面向代码克隆检测的多维源代码表征方法RLCCD的研究方案，然后就该框架的设计思路和总体架构进行详细阐述。此外也简要介绍了该框架包含的3个流程，即代码预处理、多维源代码表征学习、克隆检测任务实现。

\section{问题定义}
\label{sec:Definition}

面向代码克隆检测问题，本节首先给出如下定义：

给定两个代码片段$C_{a},C_{b}$，使用一个三元组$(C_{a},C_{b},y_{ab})$的形式来表示一对代码片段，其中$y_{ab}$表示标签。如果$(C_{a},C_{b})$是一个克隆对，那么$y_{ab}$为1，否则$y_{ab}$为0。从$n$个代码片段中构建一个带有标签的训练集$\left\{(C_{a},C_{b},y_{ab})|a,b \in n,a<b\right\}$，本文的目的是训练一个深度学习模型来学习一个可以把代码$C$映射成一个特征向量$V$的函数$f$。对于任意代码片段，计算出他们的相似度分数$S_{ab} = f(C_{a},C_{b})$并进行分类，使其分类结果尽可能接近已知的标签$y_{ab}$。在预测阶段，为了推断出两个代码片段是否是克隆对，在真假克隆对之间设置了一个阈值$k$，如果预测的相似度分数大于$k$值，那么认为两个代码片段是真克隆对，否则，认为它们是假克隆对。其中，训练一个深度学习模型将代码$C$映射成一个特征向量$V$的过程，可以视为代码表征学习的数值化过程，也是本文研究的重点。

\section{代码表征学习面临的技术挑战}
\label{sec:challenges}
目前已有的代码克隆检测方法大多遵循以下思路：（1）首先对代码片段进行预处理；（2）对处理好的代码片段进行代码表征，将其转换为中间表征；（3）根据表征的方式不同计算不同代码片段之间的相似度，完成克隆检测任务。在代码克隆检测中，源代码表征方式决定了信息抽取的程度和粒度，进而影响了后续克隆检测的精度和效率。如何得到丰富且有效的源代码表征表示，是解决代码克隆检测任务的关键所在。从目前多种维度的代码表征方法来看，现有的代码表征方式存在以下技术挑战：

（1）Token维度代码表征存在集外词问题

基于Token的方法一般会根据语法规则将源代码中的词汇单元划分出来，得到Token序列，并过滤掉无用的空格、注释、字符等，然后利用深度学习技术对其进行建模，生成具有丰富代码信息的表征向量，应用于下游代码任务。这类方法和自然语言处理（NLP）领域中常用来处理文本的方式很相似，产生一个规模巨大且稀疏的词汇表。但是，在大多数基于Token的代码克隆检测工具中，通常会将词法单元规范化，例如：将变量名用统一的标识符来代替。经过规范化Token产生的词汇表较小，导致模型学习能力有限，并且在训练过程中会出现未见过或未包含在词汇表中的词语。这些词语可能是用户自定义词、拼写错误、缩写、专有名词等。由于模型在训练阶段没有足够的信息来学习这些词语的表示，因此在实际应用中无法正确处理这些词语，从而导致模型的性能下降，这就是集外词（Out of vocabulary，简称OOV）问题。集外词问题会对模型的性能和泛化能力造成影响，严重限制了代码表征的有限性。

（2）树维度代码表征存在梯度消失问题

基于树的方法将代码通过语法解析转换成相应的抽象语法树，从而有效地表示代码的语法及其结构信息。与自然语言处理领域的长文本类似，当上下文序列很长的时候，基于树的神经网络模型容易出现梯度消失的问题，即梯度在训练过程中变得越来越小，特别是当树非常深的时候，模型会面临梯度消失问题。目前大多数基于树的代码克隆检测方法为了简化或者提高效率，通常会将生成的抽象语法树转换为完整的二叉树，在转换的过程中，不仅破坏了源代码原有的语法结构，也会增加树的高度，进一步削弱模型捕捉复杂语义的能力，导致检测性能下降。

（3）图维度代码表征存在规模开销问题

基于图的方法会将源代码表征为数据流图或者控制流图，数据流图代表了源代码中数据的走向，控制流图代表了代码中语句执行时的跳转流向。大多数基于图的代码克隆检测工具任务的核心是将图中的每个节点映射到一个低维、稠密的特征向量中，并将这些特征编码为特征矩阵，这一步通常需要大量空间开销。同时子图匹配算法是NP完全问题，计算成本过长，时间复杂度很高，因此图维度代码表征学习会存在算法计算开销大，可扩展性不好，检测结果召回率低等问题。

（4）代码表征存在信息利用不充分问题

虽然目前代码表征在Token、树、图等多种维度的研究已经取得了一定的进展，但还存在信息利用不充分的问题。代码不仅仅具有文本自然性，同时具有结构信息、语义信息。在现有的表征粒度中，Token维度的代码表征通常只关注文本自然性，抽象语法树可以捕获程序的语法结构和模式，程序依赖图可以表达程序的部分语义信息，只使用单个特征来表示代码是远远不够的，很难覆盖所有信息，因此存在信息利用不充分，特征表达不完善的问题。

\section{RLCCD框架研究方案}
\label{sec:Framework}

\subsection{研究思路及总体框架}
\label{subsec:Ideas}
针对\ref{sec:challenges}节提出的四个技术挑战，本文提出了如图\ref{fig:thinking}所示的研究思路。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/thinking}
    \caption{研究思路}\label{fig:thinking}
\end{figure}

具体地，本文主要针对代码表征学习的三个维度展开研究工作：针对Token序列特征挖掘，提出预训练增强辅助模型提取属性特征，从而解决传统基于Token序列的方法存在的集外词问题；针对抽象语法树AST特征挖掘，提出子树划分的改进方法提取结构特征，从而解决传统基于抽象语法树的方法存在的梯度消失问题；针对程序依赖图PDG特征挖掘，提出过滤机制提取语义特征，通过收集PDG的简单特征来过滤掉明显不可能为克隆的PDG对，从而解决传统基于程序依赖图的方法存在的规模开销问题。同时，考虑到经由不同表征方式处理所得到的信息通常具有互补性，且不同维度的特征都是代码表示的平行语料，具有信息等价性，因此，本文提出基于多模态学习的特征融合方法，通过融合多个代码特征，包括非结构化(顺序Token形式的代码)和结构化(抽象语法树和程序依赖图形式的代码)信息，从多维数据中学到更好的特征表示,有利于提高下游代码克隆检测任务的检测精度。

本文基于上述研究思路，设计了面向代码克隆检测的多维源代码表征方法RLCCD，框架如图\ref{fig:framework}所示。由图可见，本文提出的基本框架与\ref{subsec:Code clone detection}节提出的代码克隆检测的处理流程基本一致，并主要通过三个维度对代码表征学习环节进行改进。

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/framework}
    \caption{RLCCD 总体框架}
    \label{fig:framework}
\end{figure}

下面则分别对代码预处理、多维源代码表征学习、克隆检测任务实现三个步骤的流程和关键技术点进行介绍。

\subsection{代码预处理}
\label{subsec:Preprocess}
代码预处理的目标是生成源代码片段对应的词法单元Token序列、抽象语法树AST和程序依赖图PDG，主要包含2个流程：代码标准化、生成中间表示。

（1）代码标准化

代码标准化的任务是去除与源码无关的信息。首先是删除代码块中的注释、空行以及特殊符号，包括单行注释、多行注释、换行符等。其次，由于代码本身是一段有意义的符号，在定义转换规则时应尽最大限度地保留原有重要的信息，以免缺失关键语义联系，因此，需要确定代码转换成标记的规则，然后按照此规则将代码一一转换为对应的标记。通过深入研究并比较现有标记转换规则，发现CCLearner\cite{10.1145/1287624.1287634}对转换规则进行了实验评估，验证各个标记的有效性，因此本文参考这篇文献的转换规则，保留关键词、保留字，数字常量值用NUM替代，字符串用string替代。

（2）生成中间表示

基于标准化后的代码片段生成对应的中间表示：Token序列、抽象语法树AST和程序依赖图PDG。
抽象语法树AST最早由Yourdon等人\cite{10.1145/1499949.1499997}提出，
程序依赖图PDG最早由Ferrante J等人\cite{10.1145/24039.24041}提出，

\subsection{多维源代码表征学习}
\label{subsec:Representation}
RLCCD框架的核心步骤是源代码表征学习，其目标是学习能够表示代码片段的连续向量，表现程序理解的认知层次，获取程序的语法、语义信息，创建程序更高抽象层次上的表示，它决定着对源代码信息抽取程度的上限，决定着检测方法的预处理方式、模型设计、部署方式、运行效率，并影响后续代码克隆检测任务所能检测的精度。下面从Token序列、抽象语法树AST、程序依赖图PDG三种不同维度的代码特征表示出发，详细介绍研究方案并分析其优化改进。

（1）词法单元Token

代码是由一系列Token组成的。

针对Token序列特征挖掘，提出预训练增强辅助模型提取属性特征，从而解决传统基于Token序列的方法存在的集外词问题；

（2）抽象语法树AST

针对抽象语法树AST特征挖掘，提出子树划分的改进方法提取结构特征，从而解决传统基于抽象语法树的方法存在的梯度消失问题；

（3）程序依赖图

针对程序依赖图PDG特征挖掘，提出过滤机制提取语义特征，通过收集PDG的简单特征来过滤掉明显不可能为克隆的PDG对，从而解决传统基于程序依赖图的方法存在的计算开销大问题。

（4）特征融合方法

特征融合的目标是将提取到的属性特性、结构特征、语义特征合并，得到一个更能代表代码信息的多维特征，更具有判别能力。


\subsection{克隆检测任务实现}
\label{subsec:Clone detection}
克隆检测任务实现的核心任务是判断两个代码片段是否是真克隆对。经过\ref{subsec:Preprocess}节代码预处理和\ref{subsec:Representation}节多维源代码表征学习两个步骤，我们可以得到对应的向量表示$V_{a},V_{b}$。由于代码克隆检测问题是一个二分类问题，即给定两个代码片段，需要输出0或1，0表示它们之间不相似，1表示相似。因此需要计算代码片段1对应的多维表征$V_{a}$与代码片段2对应的多维表征$V_{b}$之间的距离$d$，并将向量距离$d$映射到0\~1之间，我们用公式\ref{e1}表示相似度$S_{ab}$。
\begin{equation}\label{e1}
    \mathrm{S_{ab}}=\operatorname{sigmoid}\left(\left|V_{a}-V_{b}\right|\right) \in[0,1]
\end{equation}
并将损失函数定义为二元交叉熵,如公式\ref{e2}所示，训练模型的目标是最小化损失。
\begin{equation}\label{e2}
    J(\Theta, \hat{y}, y)=\sum(-(y \cdot \log (\hat{y})+(1-y) \cdot \log (1-\hat{y})))
\end{equation}

综上所述，面向代码克隆检测这一下游任务，多维源代码表征学习方法RLCCD的流程图如图\ref{fig:detection}所示。
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{figures/detection}
    \caption{面向代码克隆检测的多维源代码表征学习方法RLCCD流程图}
    \label{fig:detection}
\end{figure}

\section{本章小结}
\label{sec:Summary2}
本章首先给出了代码克隆检测问题定义，然后分析了源代码表征学习在代码克隆检测过程中所面临的关键技术挑战，主要表现为Token集外词问题、树梯度消失问题、图规模开销、单个表征维度对代码信息利用率低问题。针对上述提出的四个问题，提出了本文的方法RLCCD，并介绍了其整体框架和处理流程，对其中的关键技术点进行了简要的论述。
